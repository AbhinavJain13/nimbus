######################################################
#
# This file is used for configuring asynchronous
# requests (Spot Instances and
# backfill requests) for this site
#
######################################################

###########################
# GENERAL CONFIGURATION:
###########################

# Indicates whether the Spot Instances feature
# is enabled (true) or disabled (false) for this site

si.enabled=true

# Indicates whether the backfill feature
# is enabled (true) or disabled (false) for this site

backfill.enabled=true

# A pricing model is invoked every time the Spot Instances
# environment changes. This can happen in many situations:
# when a request arrives, is canceled or terminated, when
# the quantity of resources available for Spot Instances
# increases or decreases, etc. 
#
# Given the actual requests, the maximum quantity of VMs for
# Spot Instances and the current spot price, a pricing model
# defines the next spot price based on this variables.
# Usually a spot price change causes requests to be allocated,
# if their bid is above the spot price, or pre-empted, if their
# bid is below the current spot price.
#
# This property defines which implementation of the 
# org.globus.workspace.spotinstances.PricingModel
# interface should be used by the Spot Instances module
# to set the spot price. This class will be constructed
# by reflection, so it must be in the classpath of the
# Nimbus executable.
#
# Currently there are two default implementations of that
# interface, explained as follows:
#
# ** org.globus.workspace.async.pricingmodel.MaximizeUtilizationPricingModel **
#
# This pricing model aims to satisfy the maximum number of requests, giving
# priority to higher bid requests when there aren't available VMs to fulfill
# all requests. Suitable for scientific clouds.
#
# ** org.globus.workspace.async.pricingmodel.MaximizeProfitPricingModel **
#
# This pricing model aims to maximize the revenue of the cloud provider,
# without necessarily increasing cloud utilization. Suitable for commercial
# clouds.

si.pricingmodel=org.globus.workspace.async.pricingmodel.MaximizeUtilizationPricingModel

####################################
# BASIC SPOT INSTANCE CONFIGURATION:
####################################

# Defines the amount of memory (in MegaBytes) that
# a Spot Instance of the basic type has

si.basic.mem=128

# Defines the minimum price (in allocation units) per minute
# that a Spot Instance of the basic type can cost

si.basic.minprice=0.1


#############################
# MEMORY MANAGEMENT POLICIES:
#############################

# The policies below define how the total resource pool memory is    #
# divided between ordinary Workspace Service requests                # 
# (1st class requests) and Asynchronous requests (SI or backfill     #
# requests).                                                         #
#                                                                    #
# It's important to note that these policies are preventive, in the  #
# sense that free space is reserved for future 1st class requests,   #
# but if the reserved space is still not sufficient to satisfy  a    #
# 1st class request, SI or backfill requests will be pre-empted      #
# on-the-fly in order to free the needed amount of space (emergency  #
# pre-emption)                                                       #

# This policy defines the minimum amount of free memory (in MegaBytes) 
# that should be reserved exclusively for 1st class requests, and thus
# will not be allocated for SI or backfill requests.

async.policies.minreservedmem=256

# This policy defines the maximum utilization (in %) for
# 1st class requests. When the utilization raises above this
# value, Spot Instance or backfill requests are pre-empted	
# (preventive pre-emption) in order to decrease the 
# utilization of 1st class requests.
#
# The Workspace Service will reserve an amount of free 
# memory for 1st class requests in order to ensure that
# the utilization of 1st class requests is equal or below 
# that value, unless there is no  more available memory 
# to reserve.
# 
# The amount of reserved memory for 1st class requests
# is derived from this formula:
#
#  * maxUtilization = usedMem / (usedMem + reservedMem)
#
# reorganized, becomes:
#
# * reservedMem = (1 - maxUtilization)*usedMem/maxUtilization

async.policies.maxutilization=0.7