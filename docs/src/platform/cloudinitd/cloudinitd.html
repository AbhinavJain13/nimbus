m4_include(/mcs/m4/worksp.lib.m4)
_NIMBUS_HEADER(cloudinit.d Intro)
_NIMBUS_HEADER2(n,n,n,n,n,n,y)
_NIMBUS_LEFT2_COLUMN

_NIMBUS_LEFT2_CLOUDS1_SIDEBAR(n,n,y,n,n,n,n)

_NIMBUS_LEFT2_COLUMN_END
_NIMBUS_CENTER2_COLUMN

<h2> cloudinit.d : The Nimbus Platform tool for controlling cloud applications </h2>

<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#overview">Overview</a></li>
    <ul>
        <li><a href="#service">Individual service</a></li>
        <li><a href="#bootlevels">Service Programs</a></li>
        <li><a href="#launchplan">Launch Plan</a></li>
    </ul>
<li><a href="#example">Example</a></li>
<li><a href="#svcprograms">Service Programs</a></li>
<li><a href="#clouds">Cloud settings</a></li>
<li><a href="#deps">Dependencies</a></li>
</ul>

<br />

</p>

<a name="introduction"> </a>
<h2>Introduction _NAMELINK(introduction)</h2>
<p>
cloudinit.d is a tool for launching, controlling, and monitoring cloud
applications.  If the application is simple or complex, single cloud or
multi-cloud, VM based or bare metal, or any combination of the above, 
cloudinit.d is designed to make the managment and coordination of that
application easy.
 </p>
<p>
Infrastucture clouds bring an explosion of resources to their users.
User now have the ability to create thousands of virtual machines to 
handle the needs of their applications.  The architecture of applications
is becoming much less tied to a single machine.  Applications are starting
to assume the use of reliable/redundant data stores like Cassandra and 
reliable messaging services like rabbitmq.  While this enhancement has 
brought opportiunity to applications it has also brought an unruley amount
of system administartion, coordination and management.  cloudinit.d 
automates the creation of virtual machines, their contextualization, 
and all of the messaging between VMs needed to boot strap up today's
more complicated cloud applications.  Further, it makes this process
repeatable.
 </p>
<p>
Those familiar with UNIX machines have probably made the connection 
between the name <i>cloudinit.d</i> and <i>init.d</i>.  This is, of course,
intentional.  cloudinit.d is the init.d of the cloud.  Just like init.d
organizes, manages, and efficently runs processes needed for a system,
cloudinit.d does the same for applications run across clouds.
</p>
<p>
On this page we provide an introduction to some of the important concepts
of cloudinit.d.  The details about command line arguments,
configuration file syntax, and advnaced features are described elsewhere.
</p>
<a name="overview"> </a>
<h2>Overview _NAMELINK(overview)</h2>

<a name="Service"> </a>
<h2>Service _NAMELINK(service)</h2>
<p>cloudinit.d arranges an application into three basic constructs:
<ul>
    <li>service</li>
    <li>boot level</li>
    <li>launch plan</li>
</ul>
    A service can be thought of as a single, configured Virtual Machine.  
    However
    this is a very limiting definition.  Many services can be configured
    to run in a single VM, or on an existing host that does not even have 
    to be a virtual machine at all.  A service is really just an entity 
    confined to a single machine which is responsible for a well defined
    task.  In spite of this fact in most of our examples we will merge the
    understanding of a single VM and a cloudinit.d service.
</p>
<p>
Some example services are an http server, a
node in a Cassandra pool, or a node in a rabbitmq message queue.
</p>
<a name="bootlevel"> </a>
<h2>Bootlevel _NAMELINK(bootlevel)</h2>
<p>
    A boot level is a collection of services with no dependecies on each other.
    All services in a boot level are launched at the same time.  That boot 
    level is considered complete when all of the services is it have 
    successfully started.
</p>
<p>
    Services in a boot level can be run on 1 single cloud or across many 
    different clouds.  cloudinit.d makes no assumptions about locality.
    Any service in a bootlevel can depend any service from a previous boot
    level.  For example, boot level one forms a mongoDB data store cluster.
    A web application in boot level 2 can <i>depend</i> on that mongo db
    cluster, meaning, it can acquire all of the information needed to connect
    to it dynamically at boot time.
</p>

<a name="launchplan"> </a>
<h2>Launch plan _NAMELINK(launchplan)</h2>
<p>
A launch is an ordered set of bootlevels.  To make a launch plan first all
of the services are defined, then those services are arranged into boot levels,
and finally the boot levels are put in a specific order.  This forms a 
complete cloud (or inter-cloud) application.
</p>

<a name="example"> </a>
<h2>Example programs _NAMELINK(example)</h2>
<p>
The diagram shows an example cloud application that can benefit from 
cloudinit.d.  Here we have a highly available web application which uses
mongo db for its data store, apache HTTP servers for its web application,
and a load balancer to distribute the work.  
</p>

<p>
For explainitory purposes
we put each component in a separate cloud, in practice this may or may
not be practical.  Our purpose in doing so was to show the reader that 
such a thing is possible with cloudinit.d.
</p>

<img src="../../clouds/img/cloudinitd_dia.png" width="600" height="400" />

<p>
The creator of this application would write a <i>launch plan</i> with
three boot levels.  The first has a cluster of mongo DB servers, the
second is a set of replicated HTTP servers, and the third is a load
balancer.  The plan is configured in such a way as to route the important
connection information from the mongo db cluster, to each HTTP server.
And similarly the list of HTTP servers is sent to the load balancer once 
boot level 2 completes.
</p>
<a name="svcprograms"> </a>
<h2>Service programs _NAMELINK(svcprograms)</h2>
<p>
There are three programs that are associated with a service:
<ul>
    <li>Bootpgm</li>This program runs once to setup the service.  Often
    times it will download and install software (apt-get/yum) and then
    configure that software for use considering the values and locations
    of other services in the boot.
    <li>readypgm</li>This program is run to check the status and health
    of the service.  It can be, and typically is, run many times.  As an
    example, if the service's goal was to serve http, the readypgm would
    connect to localhost:80, download a know web page and check its content.
    If all is well the readypgm returns 0 and the service is reported as
    working.  If not, the services is marked as <i>down</i> and the
    cloud application is in need of a repair.
    <li>terminatepgm</li>The terminate program is run when a service
    is shutdown.  It is there to nicely cleanup resources associated 
    with the service.
</ul>
All of these programs are user defined and written as part of the 
process of creating a cloudinit.d service.  None of the programs 
are mandatory.  If you can create a service that does not need one
of them, by all means ignore the unneeded ones. However we have
found that they tend to be needed.
</p>
<p>
As an example let us say that we want to create a service that runs 
an apache2 web server.  We find a base ubuntu VM image on our cloud
and we associate it with our service.  Now we must create the pgms
needed to turn this VM into a cloudinit.d service.  Some possible
programs are shown below:
</p>
<div class="note">
These programs can be written in any scripting language available on the
VM on which they will be run. 
</div>

<p>
bootpgm
<div class="panel"><pre>
#!/bin/bash

sudo apt-get install apache2
exit $?
</pre></div>
</p>

<p>
readypgm
<div class="panel"><pre>
#!/bin/bash

wget http://localhost
exit $?
</pre></div>
</p>

<p>
terminatepgm
<div class="panel"><pre>
#!/bin/bash

/etc/init.d/apache2 stop
exit $?
</pre></div>
</p>
<p>
All of the above programs are scp'ed to the hosting machine and then
run via ssh.  Thus the user must have ssh credentials that will work on
the associated cloud and VM, and port 22 must be open to that VM.  This
is a common scenario for infrastructure clouds.
</p>

<p>
A bootlevel is a set of services that can all be started at the same time.
In other words, a set of services that have no dependencies on each other.
These services are launched at the same time.  The boot level is considered
complete when all of the service's bootpgms successfully complete.
</p>


<a name="clouds"> </a>
<h2>Cloud settings _NAMELINK(clouds)</h2>
<p>
All of the information about where (what cloud) a particular service is to
be run on is set at the service level.  Thus a cloudinit.d application 
can run across many clouds.  It is entirely possible (and encouraged) to
have an application launched with cloudinit.d such that some services are 
in a private cloud and others are in a public cloud.  Right now cloudinit.d
works on EC2, Nimbus, and Eucalyptus.  It has a very modular interface that
will allow us to quickly add other infrastructure cloud types so we expect
that list to grow quickly.
</p>

<a name="deps"> </a>
<h2>Dependencies _NAMELINK(deps)</h2>
<p>
The goal of cloudinit.d is to orchestrate many services to work in concert
together to form a single application.  In order for this to be possible
the services need a way to discover information about each other.  For example,
if we are making a web server backed by a database we would make the database
on service and the webserver another (as is the case in our wordpress 
example).  Because the web server is dependent upon the database, We would 
put the database at bootlevel 1 and the web server at boot level 2.
</p>
<p>
However, just having the web server wait for the database to be ready is 
not enough.  The web server must know the IP address and the port number
of the data base in order to connect to it.  Further they likely need some 
sort of shared secret for making a secure connection.  Cloudinit.d handles
the exchange of this, and similar types of dependency information.  Any 
service is allowed to lookup another service (that is at a lower boot level)
and request an attribute from it.  There is a small set of statically 
defined attributes that a service has (ex: hostname, IaaS instance id, etc)
and the service can further defined its own setup attributes.
</p>
<p>
This secure exchange of service defined attributes is what makes 
cloudinit.d a powerful tool.
</p>

<br />
        
_NIMBUS_CENTER2_COLUMN_END
_NIMBUS_FOOTER1
_NIMBUS_FOOTER2
_NIMBUS_FOOTER3

