m4_include(/mcs/m4/worksp.lib.m4)
_NIMBUS_HEADER(Cloud Client Quickstart)
_NIMBUS_HEADER2(n,n,n,n,n,n,y)
_NIMBUS_LEFT2_COLUMN

_NIMBUS_LEFT2_CLOUDS1_SIDEBAR(n,n,y,n,n,n,n)

_NIMBUS_LEFT2_COLUMN_END
_NIMBUS_CENTER2_COLUMN

<h2> cloudinit.d : The Nimbus Platform tool for controling cloud applications </h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#service">Individual service</a></li>
<li><a href="#svcprograms">Service Programs</a></li>
<li><a href="#bootlevels">Service Programs</a></li>
<li><a href="#launchplan">Launch Plan</a></li>
<li><a href="#clouds">Cloud settings</a></li>
<li><a href="#deps">#Dependencies</a></li>
</ul>

<br />

</p>

<a name="introduction"> </a>
<h2>Introduction _NAMELINK(introduction)</h2>
<p>
cloudinit.d is a tool for launching and configuring a set of
interdependent VMs in a cloud (or set of clouds).
</p>
<p>
The most primitive feature of cloudinit.d is the ability to launch and
configure Virtual Machines.  That building block is used to arrange
'boot levels'.  Any one boot-level is a collection of VMs that can be
launched at the same time and have no dependencies on each other.
Any VM that is running in boot-level N can depend on values and
attributes from any VM run in boot-level N - 1.
</p>
<p>
Information about the various virtual machines in a given launch plan
can be exchanged amoung <i>services</i> in the boot.  For example,
things like hostname and IaaS instance ID of any one service can be determined 
at run time by any other service.  Further the services themselves can 
publish any variables about themselves that they choose for other services
to introspect at run time.
</p>

<p>
On this page we provide an introduction to some of the important concepts
of cloudinit.d.  Most of the details about command line arguments and 
configuration file syntax is described elsewhere.
</p>
<a name="Service"> </a>
<h2>Service _NAMELINK(service)</h2>
<p>
The smallest building block on a cloudinit.d application boot is a 
<i>service</i>.  A service is a part of the larger application that is 
confinded to a single host.  Some example services are an http server, a
node in a cassandra pool, or a node in a rabbitmq message queue.
Often times the host which runs the service is a virtual machine
which was launched specifically to run the given service, however this 
does not have to be the case.  The service can be setup to run on an 
existing host as well, the VM launch is often implied (mainly because 
it is a very convenient association) but it is not manditory.
</p>
<a name="svcprograms"> </a>
<h2>Service programs _NAMELINK(svcprograms)</h2>
<p>
There are three programs that are associated with a service:
<ul>
    <li>Bootpgm</li>This program runs once to setup the service.  Often
    times it will download and install software (apt-get/yum) and then
    configure that software for use considering the values and locations
    of other services in the boot.
    <li>readypgm</li>This program is run to check the status and health
    of the service.  It can be, and typically is, run many times.  As an
    example, if the service's goal was to serve http, the readypgm would
    connect to locahost:80, download a know web page and check its content.
    If all is well the readypgm returns 0 and the service is reported as
    working.  If not, the services is marked as <i>down</i> and the
    cloud application is in need of a repair.
    <li>terminatepgm</li>The terminate program is run when a service
    is shutdown.  It is there to nicely cleanup resources associated 
    with the service.
</ul>
All of these programs are user defined and written as part of the 
process of creating a cloudinit.d service.  None of the programs 
are mandatory.  If you can create a service that does not need one
of them, by all means ignore the unneeded ones. However we have
found that they tend to be needed.
</p>
<p>
As an example let us say that we want to create a service that runs 
an apache2 web server.  We find a base ubuntu VM image on our cloud
and we associate it with our service.  Now we must create the pgms
needed to turn this VM into a cloudinit.d service.  Some possible
programs are shown below:
</p>
<div class="note">
These programs can be writted in any scripting language available on the
VM on which they will be run. 
</div>

<p>
bootpgm
<div class="panel"><pre>
#!/bin/bash

sudo apt-get install apache2
exit $?
</pre></div>
</p>

<p>
readypgm
<div class="panel"><pre>
#!/bin/bash

wget http://localhost
exit $?
</pre></div>
</p>

<p>
terminatepgm
<div class="panel"><pre>
#!/bin/bash

/etc/init.d/apache2 stop
exit $?
</pre></div>
</p>
<p>
All of the above programs are scp'ed to the hosting machine and then
run via ssh.  Thus the user must have ssh credentials that will work on
the associated cloud and VM, and port 22 must be open to that VM.  This
is a common senerio for infrastructure clouds.
</p>

<a name="bootlevel"> </a>
<h2>Bootlevel _NAMELINK(bootlevel)</h2>
<p>
A bootlevel is a set of services that can all be started at the same time.
In other words, a set of services that have no dependencies on each other.
These services are launched at the same time.  The boot level is considered
complete when all of the service's bootpgms successfully complete.
</p>

<a name="launchplan"> </a>
<h2>Launch plan _NAMELINK(launchplan)</h2>
<p>
A launch is an ordered set of bootlevels.  To make a launch plan first all
of the services are defined, then those services are arranged into boot levels,
and finally the boot levels are put in a specific order.  This forms a 
complete cloud (or inter-cloud) application.
</p>

<a name="clouds"> </a>
<h2>Cloud settings _NAMELINK(clouds)</h2>
<p>
All of the information about where (what cloud) a particular service is to
be run on is set at the service level.  Thus a cloudinit.d application 
can run across many clouds.  It is entirely possible (and encouraged) to
have an application launched with cloudinit.d such that some services are 
in a private cloud and others are in a public cloud.  Right now cloudinit.d
works on EC2, Nimbus, and Eucalyptus.  It has a very modular interface that
will allow us to quickly add other intrastructre cloud types so we expect
that list to grow quickly.
</p>

<a name="deps"> </a>
<h2>Cloud settings _NAMELINK(deps)</h2>
<p>
The goal of cloudinit.d is to orchastrate many services to work in concert
together to form a single application.  In order for this to be possible
the services need a way to discover information about each other.  For example,
if we are making a web server backed by a database we would make the database
on service and the webserver another (as is the case in our wordpress 
example).  Because the web server is dependent upon the database, We would 
put the database at bootlevel 1 and the web server at boot level 2.
</p>
<p>
However, just having the web server wait for the database to be ready is 
not enough.  The web server must know the IP address and the port number
of the data base in order to connect to it.  Futher they likely need some 
sort of shared secret for making a secure connection.  Cloudinit.d handles
the exchange of this, and similiar types of dependecy information.  Any 
service is allowed to lookup another service (that is at a lower boot level)
and request an attribute from it.  There is a small set of statically 
defined attribures that a service has (ex: hostname, IaaS instance id, etc)
and the service can further defined its own setup attributes.
</p>
<p>
This secure exchange of service defined attributes is what makes 
cloudinit.d a powerful tool.
</p>

<br />
        
_NIMBUS_CENTER2_COLUMN_END
_NIMBUS_FOOTER1
_NIMBUS_FOOTER2
_NIMBUS_FOOTER3

